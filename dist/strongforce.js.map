{
  "version": 3,
  "file": "/home/salva/workspace/strongforce/.tmp/strongforce.js",
  "sources": [
    "consts.js",
    "Loop.js",
    "Render.js",
    "Simulator.js",
    "EventEmitter.js",
    "Model.js",
    "strongforce.js"
  ],
  "names": [],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA,ADWA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvGA,ADwGA;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "define('consts',[\n], function () {\n  'use strict';\n\n  return {\n    NOOP: function () {},\n    IS_PRECALL: false,\n    IS_POSTCALL: true\n  };\n});\n\n",
    "define('Loop',[\n], function () {\n  'use strict';\n\n  /**\n   * Options to customize the loop.\n   *\n   * @class LoopOptions\n   */\n  var defaultLoopOptions = {\n\n    /**\n     * The target model of the loop.\n     *\n     * @property rootModel\n     * @type {Model}\n     * @default undefined\n     */\n    rootModel: undefined,\n\n    /**\n     * Max time in milliseconds to be simulated on each frame to avoid making\n     * the simulation stage to take more time than that being simulated\n     *\n     * The parameter is important to avoid _spiral of death_, an effect produced\n     * due to the accumulation of a _time debt_ from frame to frame what leads\n     * to longer and longer freezes of the loop.\n     *\n     * @property maxSimulationTime\n     * @type {Number}\n     * @default 300 milliseconds\n     */\n    maxSimulationTime: 300,\n\n    /**\n     * Time in milliseconds to be simulated in each tick. As a decoupled loop,\n     * ticks per frame can vary from frame to frame.\n     *\n     * If set to 0, the simulation is coupled to the frame rate.\n     *\n     * @property simulationDelta\n     * @type {Number}\n     * @default 10 milliseconds\n     */\n    simulationDelta: 10\n  };\n\n  var requestAnimationFrame = window.requestAnimationFrame;\n\n  /**\n   * The loop is the main piece of strongforce. It coordinates simulation and\n   * rendering stages on the model. A loop takes a root model to traverse in\n   * each stage.\n   *\n   * Despite it is able to simulate the model at a constant rate, the loop is\n   * driven by `window.requestAnimationFrame()` to schedule next loop step so\n   * rendering is coined to this rate. Foreso, this is the **frame rate**\n   * as well.\n   *\n   * @class Loop\n   * @constructor\n   * @param customOptions {LoopOptions} Hash to customize the loop. The\n   * {{#crossLink \"LoopOptions/rootModel:property\"}}{{/crossLink}} key\n   * is mandatory.\n   */\n  function Loop(customOptions) {\n\n    checkOptions(customOptions);\n\n    var isRunning = false,\n        options = getCustomizedOptions(customOptions),\n        rootModel = options.rootModel;\n\n    var t, newTime, avgFrameTime = 0, currentTime,\n        pauseTime, accumulator, startTime,\n        simulationQueue = [];\n\n    /**\n     * The model target of loop.\n     *\n     * @property rootModel\n     * @type {Model}\n     * @readOnly\n     */\n    Object.defineProperty(this, 'rootModel', { value: rootModel });\n\n    /**\n     * Start the loop from the beginning, setting the current simulation time to\n     * 0.\n     *\n     * @method start\n     */\n    function start() {\n      if (!isRunning) {\n        reset(0);\n        resume();\n      }\n    }\n\n    /**\n     * Pause and force the current simulation time to 0 or other moment if\n     * indicated.\n     *\n     * @method reset\n     * @param [newOffset=0] {Number} Time in milliseconds for the current\n     * simulation time.\n     */\n    function reset(newOffset) {\n      pause();\n      t = newOffset || 0;\n      currentTime = undefined;\n      accumulator = 0;\n    }\n\n    /**\n     * Freezes the loop.\n     *\n     * @method pause\n     */\n    function pause() {\n      pauseTime = Date.now();\n      isRunning = false;\n    }\n\n    /**\n     * Continue with the loop.\n     *\n     * @method resume\n     */\n    function resume() {\n      if (!isRunning) {\n        requestAnimationFrame(loopStep);\n        isRunning = true;\n      }\n    }\n\n    /**\n     * Performs one, **and only one** loop step.\n     *\n     * @method step\n     * @param [timeToSimulate] {Number} Time to be simulated in this step.\n     * It defaults in\n     * {{#crossLink \"LoopOptions/simulationDelta:property\"}}{{/crossLink}}.\n     */\n    function step(timeToSimulate) {\n      timeToSimulate = timeToSimulate || options.simulationDelta;\n      if (!isRunning) {\n        loopStep(undefined, timeToSimulate);\n      }\n    }\n\n    /**\n     * The loop step is based on the article **Fix your timestep!**\n     * (http://gafferongames.com/game-physics/fix-your-timestep/) by\n     * _Glenn Fiedler_.\n     *\n     * The loop step is the core of strongforce. It is in charge of orchestrate\n     * the simulation and rendering stages. From frame to frame, the time frame\n     * is recorded and simulated in chunks of constant rate given by the\n     * {{#crossLink \"LoopOptions/simulationDelta:property\"}}{{/crossLink}}\n     * option.\n     *\n     * In strongforce, a {{#crossLink \"Model\"}}{{/crossLink}} instance has\n     * _facets_. A facet is a object in charge of provide a specific\n     * functionality for the model. This object can be a function or a\n     * function-like object implementing `Function.prototype.apply()` signature.\n     *\n     * During simulation and rendering stages, the\n     * {{#crossLink \"Loop/rootModel:property\"}}{{/crossLink}} is visited in a\n     * recursive way by\n     * calling {{#crossLink \"Model/simulate:method\"}}{{/crossLink}} or\n     * {{#crossLink \"Model/render:method\"}}{{/crossLink}} methods on each model\n     * in pre-order, i.e. first the model itself, then its submodels.\n     *\n     * Actually, each facet is called twice, one before visiting the children\n     * and another one after visiting them all. These calls are named pre-call\n     * and post-call and are distinguished by passing a `isPostCall` flag to\n     * the facet.\n     *\n     * @method loopStep\n     * @param requestAnimationTime {DOMHighResTimeStamp} [Not used].\n     * @param forcedTimeToSimulate {Number} Milliseconds to simulate.\n     * @private\n     */\n    function loopStep(requestAnimationTime, forcedTimeToSimulate) {\n      var frameTime;\n\n      if (!isRunning) { return; }\n\n      requestAnimationFrame(loopStep);\n\n      // Take the time now\n      newTime = Date.now();\n      (currentTime === undefined) && (currentTime = newTime);\n\n      // Calculates frame time\n      frameTime = newTime - currentTime;\n      currentTime = newTime;\n\n      // Calculating FPS according to:\n      // http://stackoverflow.com/questions/4787431/check-fps-in-\\\n      // js#answer-5111475\n      avgFrameTime += (frameTime - avgFrameTime) / 20;\n\n      // The simulation time can not be more than a specified max in order\n      // to avoid simulation times longer than the time being simulated.\n      var timeToSimulate = Math.min(\n        forcedTimeToSimulate !== undefined ? forcedTimeToSimulate : frameTime,\n        options.maxSimulationTime\n      );\n\n      // Simulate in higher precission chunks unless the feature is\n      // disabled (simulationDelta set to 0). Keeping the accumulator updated\n      // we can maintain a regular rate of simulation.\n      accumulator += timeToSimulate;\n      var dt = options.simulationDelta || accumulator;\n      while (accumulator >= dt) {\n        /*\n        TODO: Consider to make something similar for rendering:\n          Provide an `emit()` function as `scheduleUpdate()`, then apply some\n          sorting, and finally run these rendering tasks.\n        */\n        simulate(rootModel, t, dt, scheduleUpdate);\n        runSimulation();\n        t += dt;\n        accumulator -= dt;\n      }\n\n      // The interpolation value is a measure of where we are between two\n      // simulation ticks. It can be interesting to interpolate animations\n      // or other render aspects.\n      var interpolationValue = accumulator / dt;\n\n      render(rootModel, interpolationValue);\n\n      startTime = Date.now();\n    }\n\n    function render(model, interpolationValue) {\n      model.traverse('render', 'getRenderSubmodels', [interpolationValue]);\n    }\n\n    function simulate(model, t, dt, scheduleUpdate) {\n      model.traverse(\n        'simulate', 'getSimulateSubmodels',\n        [t, dt, scheduleUpdate]\n      );\n    }\n\n    function scheduleUpdate(f) {\n      simulationQueue.push(f);\n    }\n\n    function runSimulation() {\n      while (simulationQueue.length) {\n        simulationQueue.shift()();\n      }\n    }\n\n    return {\n      start: start,\n      reset: reset,\n      pause: pause,\n      resume: resume,\n      step: step,\n      /**\n       * Average frame time.\n       *\n       * @property frameTime\n       * @readOnly\n       */\n      get frameTime() {\n        return avgFrameTime;\n      }\n    };\n  }\n\n  function checkOptions(customOptions) {\n    if (customOptions.rootModel === undefined) {\n      throw new Error('The `rootModel` key is mandatory!');\n    }\n  }\n\n  function getCustomizedOptions(customOptions) {\n    var result = {};\n    for (var key in defaultLoopOptions) {\n      if (defaultLoopOptions.hasOwnProperty(key)) {\n        result[key] = customOptions[key] || defaultLoopOptions[key];\n      }\n    }\n    return result;\n  }\n\n  return Loop;\n});\n\n",
    "define('Render',[\n  './consts'\n], function(consts) {\n  'use strict';\n\n  var NOOP = consts.NOOP,\n      IS_PRECALL = consts.IS_PRECALL,\n      IS_POSTCALL = consts.IS_POSTCALL;\n\n  /**\n   * The render is the facet of a model in charge of realize the model. Usually\n   * by drawing it.\n   *\n   * This class provides a functor skeleton to ease the implementation of\n   * complex renders. The developer can extend this class and override\n   * {{#crossLink \"Render/render:method\"}}{{/crossLink}}\n   * or {{#crossLink \"Render/postRender:method\"}}{{/crossLink}} methods to\n   * provide the behaviors for the pre and post calls of the render stage.\n   *\n   *     function GameOfLifeCell() {\n   *       Render.apply(this, arguments);\n   *       // Your code...\n   *     }\n   *     GameOfLifeCell.prototype = Object.create(Render.prototype);\n   *     GameOfLifeCell.prototype.constructor = GameOfLifeCell;\n   *\n   * @class Render\n   * @param model {Model} The model for which this functor is being\n   * instantiated.\n   * @param [modelParameters]* {Any} The same parameters passed to the model\n   * constructor.\n   * @constructor\n   */\n  function Render() { }\n\n  /**\n   * Delegate on {{#crossLink \"Render/render:method\"}}{{/crossLink}}\n   * or {{#crossLink \"Render/postRender:method\"}}{{/crossLink}}\n   * depending on the first component of `args` parameter which determine\n   * if this invocation is the pre-call or the post-call.\n   * The method passes all the arguments to the delegated methods except\n   * `isPostCall` flag which is replaced by the model being simulated.\n   *\n   * The function follows the signature of `Function.prototype.apply()`.\n   *\n   * @method apply\n   * @private\n   * @param model {Model} Model being simulated.\n   * @param [args=Array] {Array} Arguments for the functor. For renders,\n   * these arguments are `isPostCall` flag and the simulation interpolation\n   * value.\n   */\n  Render.prototype.apply = function(model, args) {\n    var isPostCall = args[0],\n        newArgs = [model].concat(args.slice(1));\n    this[isPostCall ? 'postRender' : 'render'].apply(this, newArgs);\n  };\n\n  /**\n   * Performs the pre-call for the model's rendering.\n   *\n   * @method render\n   * @param model {Model} Model being simulated.\n   * @param interpolationValue {Number} A measure of how much time remains to\n   * simulate in the interval `[0, 1)`. The value can be used as an\n   * interpolation value for rendering smooth animations.\n   */\n  Render.prototype.render = NOOP;\n\n  /**\n   * Performs the post-call for the model's rendering.\n   *\n   * @method postRender\n   * @param model {Model} Model being simulated.\n   * @param interpolationValue {Number} A measure of how much time remains to\n   * simulate in the interval `[0, 1)`. The value can be used as an\n   * interpolation value for rendering smooth animations.\n   */\n  Render.prototype.postRender = NOOP;\n\n  /**\n   * Helper method to trigger the render pre-call of a model. It is usually\n   * used from the {{#crossLink \"Render/render:method\"}}{{/crossLink}}\n   * method.\n   *\n   * @method delegateToRender\n   * @param model {Model} Model in which delegate.\n   * @param [args]* {Any} The parameters passed to the render pre-call of the\n   * model. It is convinient to simply bypass the same arguments received in the\n   * {{#crossLink \"Render/render:method\"}}{{/crossLink}} method.\n   */\n  Render.prototype.delegateToRender = function (model) {\n    var args = [IS_PRECALL].concat(Array.prototype.slice.call(arguments, 1));\n    model.render.apply(model, args);\n  };\n\n  /**\n   * Helper method to trigger the render post-call of a model. It is usually\n   * used from the {{#crossLink \"Render/postRender:method\"}}{{/crossLink}}\n   * method.\n   *\n   * @method delegateToPostRender\n   * @param model {Model} Model in which delegate.\n   * @param [args]* {Any} The parameters passed to the render post-call of the\n   * model. It is convinient to simply bypass the same arguments received in the\n   * {{#crossLink \"Render/postRender:method\"}}{{/crossLink}} method.\n   */\n  Render.prototype.delegateToPostRender = function (model) {\n    /* TODO: Consider make a factory for delegations */\n    var args = [IS_POSTCALL].concat(Array.prototype.slice.call(arguments, 1));\n    model.render.apply(model, args);\n  };\n\n  return Render;\n});\n\n",
    "define('Simulator',[\n  './consts'\n], function(consts) {\n  'use strict';\n\n  var NOOP = consts.NOOP;\n\n  /**\n   * The simulator is the facet of a model in charge of business logic.\n   *\n   * This class provides a functor skeleton to ease the implementation of\n   * complex simulators. The developer can extend this class and override\n   * {{#crossLink \"Simulator/simulate:method\"}}{{/crossLink}}\n   * or {{#crossLink \"Simulator/postSimulate:method\"}}{{/crossLink}}\n   * methods to provide the behaviors for the pre and post calls of the\n   * simulation stage.\n   *\n   *     function GameOfLife() {\n   *       Simulator.apply(this, arguments);\n   *       // Your code...\n   *     }\n   *     GameOfLife.prototype = Object.create(Simulator.prototype);\n   *     GameOfLife.prototype.constructor = GameOfLife;\n   *\n   * @class Simulator\n   * @param model {Model} The model for which this functor is being\n   * instantiated.\n   * @param [modelParameters]* {Any} The same parameters passed to the model\n   * constructor.\n   * @constructor\n   */\n  function Simulator() { }\n\n  /**\n   * Delegate on {{#crossLink \"Simulator/simulate:method\"}}{{/crossLink}}\n   * or {{#crossLink \"Simulator/postSimulate:method\"}}{{/crossLink}}\n   * depending on the first component of `args` parameter which determine\n   * if this invocation is the pre-call or the post-call.\n   * The method passes all the arguments to the delegated methods except\n   * `isPostCall` flag which is replaced by the model being simulated.\n   *\n   * The function follows the signature of `Function.prototype.apply()`.\n   *\n   * @method apply\n   * @private\n   * @param model {Model} Model being simulated.\n   * @param [args=Array] {Array} Arguments for the functor. For simulators,\n   * these arguments are `isPostCall` flag, time since the start of the\n   * simulation, time to be simulated and the `update()` function to schedule\n   * model updates.\n   */\n  Simulator.prototype.apply = function(model, args) {\n    args = args || [];\n    var isPostCall = args[0],\n        newArgs = [model].concat(args.slice(1));\n    this[isPostCall ? 'postSimulate' : 'simulate'].apply(this, newArgs);\n  };\n\n  /**\n   * Performs the pre-call for the model's simulation. You can use the last\n   * parameter, the `update()` callback, to delay model updates after the\n   * completion of simulation stage (i.e, **after pre and post calls**):\n   *\n   *     GameOfLife.prototype.simulate = function (model, t, dt, update) {\n   *       // Read the model...\n   *       var aliveNeightbours = this.getAliveNeightbours(model);\n   *       update(function () {\n   *         // Update the model...\n   *         if (model.isAlive && aliveNeightbours < 3) {\n   *           model.isAlive = false;\n   *         }\n   *       });\n   *     };\n   *\n   * @method simulate\n   * @param model {Model} Model being simulated.\n   * @param t {Number} Time in milliseconds passed since the start of the\n   * simulation.\n   * @param dt {Number} Amount of time in milliseconds to simulate.\n   * @param update {Function} A callback to schedule a function to be run once\n   * the simulation stage has ended.\n   */\n  Simulator.prototype.simulate = NOOP;\n\n  /**\n   * Performs the post-call for the model's simulation. You can use the last\n   * parameter, the `update()` callback, to delay model updates after the\n   * completion of simulation stage.\n   * See {{#crossLink \"Simulator/simulate:method\"}}{{/crossLink}} for an usage\n   * example.\n   *\n   * @method postSimulate\n   * @param model {Model} Model being simulated.\n   * @param t {Number} Time in milliseconds passed since the start of the\n   * simulation.\n   * @param dt {Number} Amount of time in milliseconds to simulate.\n   * @param update {Function} A callback to schedule a function to be run once\n   * the simulation stage has ended.\n   */\n  Simulator.prototype.postSimulate = NOOP;\n\n  return Simulator;\n});\n\n",
    "define('EventEmitter',[\n], function () {\n  'use strict';\n\n  /**\n   * Provide methods for dispatching events and add or remove listeners to\n   * specified types of events.\n   *\n   * @class EventEmitter\n   * @constructor\n   */\n  function EventEmitter() {\n    var self = this;\n\n    /**\n     * Keeps the list of listeners by event type.\n     *\n     * @property _listeners\n     * @type {Object}\n     * @private\n     * @final\n     */\n    Object.defineProperty(this, '_listeners', { value: {} });\n\n    /**\n     * Bound version of\n     * {{#crossLink \"EventEmitter/_bubbleEvent:method\"}}{{/crossLink}}\n     * method. This bound version allow the\n     * porxy to be naturally unique as calls to\n     * {{#crossLink \"EventEmitter/addEventListener:method\"}}{{/crossLink}}\n     * with same arguments are ignored.\n     *\n     * @method _boundBubbleEvent\n     * @param evt {StrongforceModelEvent} the event to be dispatched.\n     * @private\n     * @final\n     */\n    Object.defineProperty(this, '_boundBubbleEvent', {\n      value: function (evt) {\n        self._bubbleEvent(evt);\n      }\n    });\n  }\n\n  /**\n   * Emit an event from the instance.\n   *\n   * @method dispatchEvent\n   * @param type {String} The type of the event.\n   * @param [event=Object] {Object} Hash of event's properties.\n   */\n  EventEmitter.prototype.dispatchEvent = function(type, event) {\n    event = event || {};\n    Object.defineProperty(event, 'type', { value: type });\n    Object.defineProperty(event, 'target', { value: this });\n    Object.defineProperty(event, 'currentTarget', { value: this });\n    Object.defineProperty(event, 'timestamp', { value: Date.now() });\n    this._runListeners(type, event);\n    this._runListeners('*', event);\n  };\n\n  /**\n   * Synchronously run the listeners for an event type removing _only once_\n   * listeners.\n   *\n   * @method _runListeners\n   * @param type {String} The type of the event for which the listeners\n   * will be executed.\n   * @param event {Object} Hash of event's properties.\n   * @private\n   */\n  EventEmitter.prototype._runListeners = function(type, event) {\n    var listeners = this._listeners[type] || [],\n        newListeners = [];\n\n    listeners.forEach(function onCallback(pair) {\n      var callback = pair[0];\n      var once = pair[1];\n      callback(event);\n      if (!once) { newListeners.push(pair); }\n    });\n    this._listeners[type] = newListeners;\n  };\n\n  /**\n   * Makes the current instance to dispatch an event each time the other\n   * emitter, passed as parameter, dispatches an event. All properties from\n   * the original event are kepts unaltered except the `currentTarget`\n   * property which is updated to point the current instance.\n   *\n   * @method proxyEventsFrom\n   * @param anotherEmitter {EventEmitter} the emitter to be proxied.\n   */\n  EventEmitter.prototype.proxyEventsFrom = function (anotherEmitter) {\n    if (!anotherEmitter ||\n        typeof anotherEmitter.addEventListener !== 'function') {\n      return;\n    }\n\n    anotherEmitter.addEventListener('*', this._boundBubbleEvent);\n  };\n\n  /**\n   * Dispatch a new event based on another received from an EventEmitter\n   * instance being proxied by this instance. The `currentTarget` property is\n   * updated to the current instance.\n   *\n   * This implementation is not directly used as it needs to be bound to\n   * the current instance. This is done in the constructor.\n   *\n   * @method _bubbleEvent\n   * @param evt {StrongforceModelEvent} the event to be dispatched.\n   * @private\n   */\n  EventEmitter.prototype._bubbleEvent = function (evt) {\n    var newEvt = Object.create(evt);\n    Object.defineProperty(newEvt, 'currentTarget', { value: this });\n    this._runListeners(newEvt.type, newEvt);\n    this._runListeners('*', newEvt);\n  };\n\n  /**\n   * Add a listener for an event type to be executed synchronously every time\n   * the model emits an event of the provided type. You can optionally indicate\n   * the listener should run only once.\n   *\n   * You can listen for any kind of event specifying `*` as type.\n   *\n   * @method addEventListener\n   * @param type {String} The type of the event for which the listener\n   * will be attached.\n   * @param callback {Function} The listener is a function that will receive a\n   * {{#crossLink \"StrongforceModelEvent\"}}{{/crossLink}} parameter.\n   * @param [once=false] {Boolean} If set to `true`, the listener will be\n   * executed only once and automatically removed after the execution.\n   */\n  EventEmitter.prototype.addEventListener = function(type, callback, once) {\n    var listeners = this._listeners,\n        typeListeners = listeners[type] = (listeners[type] || []);\n\n    if (!typeListeners.some(alreadyListening)) {\n      typeListeners.push([callback, once]);\n    }\n\n    function alreadyListening(pair) {\n      return pair[0] === callback;\n    }\n  };\n\n  /**\n   * Remove one listener for the specified event type.\n   *\n   * @method removeEventListener\n   * @param type {String} The type of the event for which the listener\n   * will be removed.\n   * @param callback {Function} The listener to remove.\n   */\n  EventEmitter.prototype.removeEventListener = function(type, callback) {\n    var listeners = this._listeners,\n        typeListeners = listeners[type] = listeners[type] || [],\n        position = -1;\n\n    for (var l = 0, pair; (pair = typeListeners[l]) && position < 0; l++) {\n      if (pair[0] === callback) { position = l; }\n    }\n\n    if (position !== -1) {\n      listeners[type].splice(position, 1);\n    }\n  };\n\n  /**\n   * Remove all listeners for an event type.\n   *\n   * @method removeAllEventListener\n   * @param type {String} The type of the event for which the listener\n   * will be removed.\n   */\n  EventEmitter.prototype.removeAllEventListener = function (type) {\n    this._listeners[type] = [];\n  };\n\n  return EventEmitter;\n\n  /**\n   * The type of data received by a listener attached by using\n   * {{#crossLink \"EventEmitter/addEventListener:method\"}}{{/crossLink}}.\n   *\n   * @class StrongforceModelEvent\n   */\n\n  /**\n   * The model dispatching the event.\n   *\n   * @property target\n   * @type {Model}\n   */\n\n  /**\n   * The type of the event.\n   *\n   * @property type\n   * @type {String}\n   */\n\n  /**\n   * The moment at which the event has been dispatched.\n   *\n   * @property timestamp\n   * @type {Number}\n   */\n\n});\n\n",
    "define('Model',[\n  './consts',\n  './EventEmitter'\n], function (consts, EventEmitter) {\n  'use strict';\n\n  var NEXT_ID = 1,\n      IS_PRECALL = consts.IS_PRECALL,\n      IS_POSTCALL = consts.IS_POSTCALL,\n      NOOP = consts.NOOP;\n\n  /**\n   * The model is the target of the strongforce {{#crossLink \"Loop\"}}\n   * {{/crossLink}}. It follows a composite pattern to allow aggregation and\n   * represents what is simulated and rendered through _facets_.\n   *\n   * A facet is a function or a functor (i.e **a function-like object**) which\n   * reveals a specific behaviour depending on the stage being executed by the\n   * strongforce's loop.\n   *\n   * The developer can extend this class, hook the proper facets and provide\n   * {{#crossLink \"Model/getSubmodels:method\"}}{{/crossLink}} method to return\n   * other submodels.\n   *\n   *     // [Inheritance]\n   *     function GameOfLifeBoard(width, height) {\n   *       // Your code...\n   *       this.width = width;\n   *       this.height = height;\n   *       this.cells = [];\n   *       for (var i = 0; i < width; i++) {\n   *         for (var j = 0; j < height; j++) {\n   *           this.cells.push(new Cell(i, j));\n   *         }\n   *       }\n   *       Model.apply(this, arguments); // it's very important to keep this\n   *                                     // call at the end of the model.\n   *     }\n   *     GameOfLifeBoard.prototype = Object.create(Model.prototype);\n   *     GameOfLifeBoard.prototype.constructor = GameOfLifeBoard;\n   *\n   *     // [Hook the facets]\n   *     GameOfLifeBoard.prototype.simulate = GameOfLifeBoardSimulator;\n   *     GameOfLifeBoard.prototype.render = GameOfLifeBoardRender;\n   *\n   *     // [Specify submodels]\n   *     GameOfLifeBoard.prototype.getSubmodels = function () {\n   *       return this.cells;\n   *     };\n   *\n   * @class Model\n   * @uses EventEmitter\n   * @constructor\n   */\n  function Model() {\n    EventEmitter.apply(this);\n\n    /**\n     * A unique integer number to identify the model instance.\n     *\n     * @property id\n     * @final\n     * @type {Number}\n     */\n    Object.defineProperty(this, 'id', { value: NEXT_ID++ });\n\n    // Setup facets must be the last thing to do!\n    Model.setupFacets(this, [].slice.call(arguments, 0));\n  }\n  var EventEmitterPrototype = EventEmitter.prototype;\n  for (var property in EventEmitterPrototype) {\n    if (EventEmitterPrototype.hasOwnProperty(property)) {\n      Model.prototype[property] = EventEmitterPrototype[property];\n    }\n  }\n\n  /**\n   * Detect if the facet hooks\n   * ({{#crossLink \"Model/facets:property\"}}{{/crossLink}}) of a model\n   * are pointing to classes extending helper functors\n   * {{#crossLink \"Simulator\"}}{{/crossLink}} and\n   * {{#crossLink \"Render\"}}{{/crossLink}}.\n   * If so, replace them by fresh instances from those classes.\n   *\n   * @method setupFacets\n   * @param model {Model} The model to hook up.\n   * @param args {Array} An array of arguments to be passed along the model\n   * itself to the functor constructor when instantiating it.\n   * @static\n   * @private\n   */\n  Model.setupFacets = function (model, args) {\n    var isAFacetConstructor, facetPrototype, newFacet, facets;\n\n    facets = Model.facets;\n\n    for (var i = 0, facet; (facet = facets[i]); i++) {\n      facetPrototype = model[facet].prototype;\n      isAFacetConstructor = facetPrototype &&\n                            facetPrototype.apply !== undefined &&\n                            model[facet].apply !== undefined;\n\n      if (isAFacetConstructor) {\n        newFacet = Object.create(facetPrototype);\n        model[facet].apply(newFacet, [model].concat(args));\n        model[facet] = newFacet;\n      }\n    }\n  };\n\n  /**\n   * List of facets. Currently they are\n   * {{#crossLink \"Model/simulate:method\"}}{{/crossLink}} and\n   * {{#crossLink \"Model/render:method\"}}{{/crossLink}}.\n   *\n   * @property facets\n   * @type {Array}\n   * @static\n   * @private\n   */\n  Model.facets = ['simulate', 'render'];\n\n  /**\n   * Passes through the model in pre-order calling a specified method. The\n   * current model is visited twice. The first time the method is called, it\n   * is said to be the **pre-call**. The second call only happens after visiting\n   * all the children models and it is said to be the **post-call**.\n   *\n   * @method traverse\n   * @param methodName {String} The name of the method to call through the\n   * model.\n   * @param submodelsGetterName {String} The name of the method to call in order\n   * to get the submodels.\n   * @param methodArgs {Array} List of parameters to pass to the method after\n   * the `isPostCall` flag.\n   */\n  Model.prototype.traverse =\n  function(methodName, submodelsGetterName, methodArgs) {\n\n    var submodels,\n        submodelsMethod,\n        method = this[methodName],\n        isMethodApplicable = method && typeof method.apply === 'function';\n\n    methodArgs = [null].concat(methodArgs);\n\n    // pre-call\n    if (isMethodApplicable) {\n      methodArgs[0] = IS_PRECALL;\n      method.apply(this, methodArgs);\n    }\n\n    // get submodules\n    /*\n    TODO: Consider applying getSubmodels() to the facet instead of model\n    and passing the model as first parameter as already done with the main\n    facet method.\n    */\n    submodels = [];\n    submodelsMethod = this[submodelsGetterName];\n    if (submodelsMethod && typeof submodelsMethod.apply === 'function') {\n      submodels = submodelsMethod.apply(this) || [];\n    }\n\n    // traverse submodules\n    var args = arguments;\n    submodels.forEach(function (submodel) {\n      submodel.traverse.apply(submodel, args);\n    });\n\n    // post-call\n    if (isMethodApplicable) {\n      methodArgs[0] = IS_POSTCALL;\n      method.apply(this, methodArgs);\n    }\n  };\n\n  /**\n   * Facet to perform the simulation step of the model. Instead of simply\n   * called, the facet is revealed by calling `apply()` over the model so it can\n   * be implemented either by a simple JavaScript function or a complex functor.\n   *\n   * If set to a class extending the {{#crossLink \"Simulator\"}}{{/crossLink}}\n   * class, when a new model is created, a new instance of the simulator class\n   * is assigned to the instance's property.\n   *\n   * @method simulate\n   * @param isPostCall {Boolean} Flag indicating if it is the post-call or not.\n   * @param t {Number} Time in milliseconds passed since the start of the\n   * simulation.\n   * @param dt {Number} Amount of time in milliseconds to simulate.\n   * @param update {Function} A callback to schedule a function to be run once\n   * the simulation stage has ended.\n   */\n  Model.prototype.simulate = NOOP;\n\n  /**\n   * Return the (dynamic) list of submodels for the simulation stage. If it is\n   * not overriden, it delegates in the\n   * {{#crossLink \"Model/getSubmodels:method\"}}{{/crossLink}} method.\n   *\n   * @method getSimulateSubmodels\n   * @return {Iterable} An object implementing `Array.prototype.forEach()`\n   * signature.\n   */\n  Model.prototype.getSimulateSubmodels = function() {\n    return this.getSubmodels();\n  };\n\n  /**\n   * Facet to perform the render step of the model. Instead of simply\n   * called, the facet is revealed by calling `apply()` over the model so it can\n   * be implemented either by a simple JavaScript function or a complex functor.\n   *\n   * If set to a class extending the {{#crossLink \"Render\"}}{{/crossLink}}\n   * class, when a new model is created, a new instance of the simulator class\n   * is assigned to the instance's property.\n   *\n   * @method render\n   * @param isPostCall {Boolean} Flag indicating if it is the post-call or not.\n   * @param interpolationValue {Number} A measure of how much time remains to\n   * simulate in the interval `[0, 1)`. The value can be used as an\n   * interpolation value for rendering smooth animations.\n   */\n  Model.prototype.render = NOOP;\n\n  /**\n   * Return the (dynamic) list of submodels for the render stage. If it is\n   * not overriden, it delegates in the\n   * {{#crossLink \"Model/getSubmodels:method\"}}{{/crossLink}} method.\n   *\n   * @method getRenderSubmodels\n   * @return {Iterable} An object implementing `Array.prototype.forEach()`\n   * signature.\n   */\n  Model.prototype.getRenderSubmodels = function() {\n    return this.getSubmodels();\n  };\n\n  /**\n   * Return the (dynamic) list of submodels composing the current model.\n   *\n   * @method getSubmodels\n   * @return {Iterable} An object implementing `Array.prototype.forEach()`\n   * signature.\n   */\n  Model.prototype.getSubmodels = function() {\n    return [];\n  };\n\n  return Model;\n});\n\n",
    "define('strongforce',[\n  './consts',\n  './Loop',\n  './Render',\n  './Simulator',\n  './Model',\n  './EventEmitter'\n], function (consts, Loop, Render, Simulator, Model, EventEmitter) {\n  'use strict';\n\n  return {\n    consts: consts,\n    Loop: Loop,\n    Render: Render,\n    Simulator: Simulator,\n    Model: Model,\n    EventEmitter: EventEmitter\n  };\n});\n\n"
  ]
}